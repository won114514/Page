---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';
import { encrypt } from '../../utils/crypto';

export async function getStaticPaths() {
  const posts = await getCollection('posts', ({ data }) => {
    return data.draft !== true;
  });

  return posts.map((post) => ({
    params: { slug: post.slug },
    props: { post },
  }));
}

interface Props {
  post: any;
}

// è®¡ç®—æ–‡ç« å­—æ•°
const countWords = (content: string) => {
  // ç§»é™¤Markdownè¯­æ³•
  const text = content
    .replace(/\n/g, ' ')
    .replace(/\*\*(.*?)\*\*/g, '$1')
    .replace(/\*(.*?)\*/g, '$1')
    .replace(/`(.*?)`/g, '$1')
    .replace(/#{1,6}\s/g, '')
    .replace(/!\[.*?\]\(.*?\)/g, '')
    .replace(/\[.*?\]\(.*?\)/g, '$1')
    .trim();
  return text.length > 0 ? text.length : 0;
};

const { post } = Astro.props;
const isEncrypted = post.data.encrypt === true;
const encryptionHint = post.data.aes_key_hint;

// ä½¿ç”¨æ–‡ç«  front-matter ä¸­å®šä¹‰çš„å¯†é’¥æ¥åŠ å¯†å†…å®¹
// å¦‚æœæ²¡æœ‰å®šä¹‰ï¼Œåˆ™ä½¿ç”¨é»˜è®¤å¯†é’¥
const ENCRYPTION_KEY = post.data.aes_key || 'default-key';

// æ¸²æŸ“å¹¶åŠ å¯†æ–‡ç« å†…å®¹
let encryptedContent = '';
if (isEncrypted) {
  // ç›´æ¥åŠ å¯†æ–‡ç« çš„åŸå§‹Markdownå†…å®¹
  // è¿™æ ·æ„å»ºäº§ç‰©ä¸­åªä¼šåŒ…å«åŠ å¯†åçš„å†…å®¹ï¼Œä¸ä¼šåŒ…å«æ˜æ–‡
  encryptedContent = encrypt(post.body, ENCRYPTION_KEY);
}

// å¯¹äºåŠ å¯†æ–‡ç« ï¼Œæˆ‘ä»¬ä¸æ¸²æŸ“Contentç»„ä»¶
// è¿™æ ·æ˜æ–‡å†…å®¹å°±ä¸ä¼šå‡ºç°åœ¨æ„å»ºäº§ç‰©ä¸­
let Content = null;
if (!isEncrypted) {
  const rendered = await post.render();
  Content = rendered.Content;
}
---

<BaseLayout title={post.data.title}>
  <article>
    <h1>{post.data.title}</h1>
    <div class="post-meta">
      {new Date(post.data.date).toLocaleDateString('zh-CN')} Â· {countWords(post.body)} å­—
    </div>
    
    {isEncrypted ? (
      <div id="encrypted-content">
        <div class="encryption-container">
          <h2>ğŸ”’ æ–‡ç« å·²åŠ å¯†</h2>
          {encryptionHint && (
            <p class="encryption-hint">{encryptionHint}</p>
          )}
          <form id="decryption-form">
            <input 
              type="password" 
              id="decryption-key" 
              placeholder="è¯·è¾“å…¥è§£å¯†å¯†ç "
              required
            />
            <button type="submit">è§£å¯†</button>
          </form>
          <p id="decryption-error" class="error-message"></p>
        </div>
        <div id="decrypted-content" style="display: none;">
          <!-- è§£å¯†åçš„å†…å®¹å°†é€šè¿‡ JavaScript åŠ¨æ€æ’å…¥ -->
        </div>
      </div>
    ) : (
      <Content />
    )}
  
  <!-- Back to Top Button -->
  <button aria-label="Back to Top" class="back-to-top">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  </button>

  <style scoped>
    /* Back to Top Button Styles */
    .back-to-top {
      position: fixed;
      background-color: var(--bg-color);
      color: var(--text-color);
      border: 1px solid var(--border-color);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      z-index: 1000;
      height: 3.5rem;
      width: 3.5rem;
    }

    /* å¤§å±å¹•ï¼šæŒ‰é’®ä½äºå®¹å™¨å³ä¾§ */
    @media (min-width: 841px) {
      .back-to-top {
        right: calc(50% - 400px - 1rem);
        bottom: 2rem;
      }
    }

    /* ä¸­ç­‰å±å¹•ï¼šæŒ‰é’®ä½äºçª—å£å³ä¾§ */
    @media (max-width: 840px) {
      .back-to-top {
        right: 1.5rem;
        bottom: 2rem;
      }
    }

    /* å°å±å¹•ï¼šæŒ‰é’®ä½äºçª—å£å³ä¾§ï¼Œå°ºå¯¸å‡å° */
    @media (max-width: 480px) {
      .back-to-top {
        right: 1rem;
        bottom: 1rem;
        height: 3rem;
        width: 3rem;
      }
    }

    .back-to-top:hover {
      background-color: var(--accent-color);
      color: var(--bg-color);
      transform: translateY(-3px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    /* åŠ å¯†ç›¸å…³æ ·å¼ */
    .encryption-container {
      background-color: var(--bg-color);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 2rem;
      margin: 2rem 0;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }
    
    .encryption-container h2 {
      margin-top: 0;
      margin-bottom: 1.5rem;
      color: var(--text-color);
    }
    
    .encryption-hint {
      color: var(--text-color-secondary);
      margin-bottom: 1.5rem;
      font-style: italic;
    }
    
    #decryption-form {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      max-width: 400px;
      margin: 0 auto;
    }
    
    #decryption-key {
      padding: 0.75rem 1rem;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--bg-color);
      color: var(--text-color);
      font-size: 1rem;
    }
    
    #decryption-key:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
    }
    
    #decryption-form button {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 4px;
      background-color: var(--accent-color);
      color: var(--bg-color);
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    #decryption-form button:hover {
      background-color: var(--accent-color-hover);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    
    .error-message {
      color: #dc3545;
      margin-top: 1rem;
      font-size: 0.9rem;
    }
    
    /* å“åº”å¼è®¾è®¡ */
    @media (max-width: 600px) {
      .encryption-container {
        padding: 1.5rem;
      }
      
      #decryption-form {
        max-width: 100%;
      }
    }
  </style>

  <script>
    // Back to Top Button Functionality
    const backToTopButton = document.querySelector('.back-to-top') as HTMLElement | null;
    
    if (backToTopButton) {
      // Show/hide button based on scroll position
      window.addEventListener('scroll', () => {
        if (window.scrollY > 300) {
          backToTopButton.style.display = 'flex';
        } else {
          backToTopButton.style.display = 'none';
        }
      });
      
      // Scroll to top when button is clicked
      backToTopButton.addEventListener('click', () => {
        window.scrollTo({
          top: 0,
          behavior: 'smooth'
        });
      });
      
      // Initially hide button
      backToTopButton.style.display = 'none';
    }
  </script>

  {isEncrypted && (
    <>
      <!-- å­˜å‚¨åŠ å¯†å†…å®¹çš„éšè—å…ƒç´  -->
      <div id="encrypted-content-storage" style="display: none;">{encryptedContent}</div>
      
      <script>
        // ä½¿ç”¨ç«‹å³æ‰§è¡Œå‡½æ•°è¡¨è¾¾å¼ (IIFE) å°è£…è„šæœ¬ï¼Œé¿å…å˜é‡åå†²çª
        (function() {
          // è§£å¯†åŠŸèƒ½
          const decryptionForm = document.getElementById('decryption-form');
          const decryptionKey = document.getElementById('decryption-key') as HTMLInputElement | null;
          const decryptionError = document.getElementById('decryption-error');
          const encryptedContainer = document.querySelector('.encryption-container') as HTMLElement | null;
          const decryptedContent = document.getElementById('decrypted-content') as HTMLElement | null;
          
          // ä»éšè—å…ƒç´ è·å–åŠ å¯†çš„å†…å®¹
          const encryptedContentStorage = document.getElementById('encrypted-content-storage');
          const encryptedContentFromServer = encryptedContentStorage ? encryptedContentStorage.textContent : '';
          
          if (decryptionForm && decryptionKey && decryptionError && encryptedContainer && decryptedContent && encryptedContentFromServer) {
            decryptionForm.addEventListener('submit', async (e) => {
              e.preventDefault();
              
              const password = decryptionKey.value.trim();
              if (!password) {
                decryptionError.textContent = 'è¯·è¾“å…¥å¯†ç ';
                return;
              }
              
              try {
                // ä½¿ç”¨ Web Crypto API è¿›è¡Œè§£å¯†
                const decryptedText = await decryptWithWebCrypto(encryptedContentFromServer, password);
                
                // éªŒè¯è§£å¯†æ˜¯å¦æˆåŠŸï¼ˆç®€å•æ£€æŸ¥ï¼‰
                if (!decryptedText || decryptedText.length < 10) {
                  throw new Error('è§£å¯†å¤±è´¥ï¼Œè¯·æ£€æŸ¥å¯†ç æ˜¯å¦æ­£ç¡®');
                }
                
                // è§£æ Markdown å¹¶æ˜¾ç¤ºå†…å®¹
                decryptedContent.innerHTML = await markdownToHtml(decryptedText);
                
                // æ˜¾ç¤ºè§£å¯†åçš„å†…å®¹
                encryptedContainer.style.display = 'none';
                decryptedContent.style.display = 'block';
                decryptionError.textContent = '';
                
                // è§¦å‘å†…å®¹è¿›å…¥åŠ¨ç”»
                decryptedContent.style.opacity = '0';
                decryptedContent.style.transform = 'translateY(20px)';
                
                requestAnimationFrame(() => {
                  decryptedContent.style.transition = 'opacity 0.6s ease-out, transform 0.6s ease-out';
                  decryptedContent.style.opacity = '1';
                  decryptedContent.style.transform = 'translateY(0)';
                });
                
              } catch (error) {
                decryptionError.textContent = 'è§£å¯†å¤±è´¥ï¼Œè¯·æ£€æŸ¥å¯†ç æ˜¯å¦æ­£ç¡®';
                console.error('è§£å¯†é”™è¯¯:', error);
              }
            });
          }
          
          // Web Crypto API è§£å¯†å‡½æ•°
          async function decryptWithWebCrypto(encryptedText: string, password: string): Promise<string> {
            try {
              const [ivBase64, encryptedData] = encryptedText.split(':');
              const iv = new Uint8Array(atob(ivBase64).split('').map(c => c.charCodeAt(0)));
              const encrypted = new Uint8Array(atob(encryptedData).split('').map(c => c.charCodeAt(0)));
              
              // ä»å¯†ç æ´¾ç”Ÿå¯†é’¥
              const keyMaterial = await crypto.subtle.importKey(
                'raw',
                new TextEncoder().encode(password),
                { name: 'PBKDF2' },
                false,
                ['deriveKey']
              );
              
              const key = await crypto.subtle.deriveKey(
                {
                  name: 'PBKDF2',
                  salt: new TextEncoder().encode('won-blog-salt'),
                  iterations: 100000,
                  hash: 'SHA-256'
                },
                keyMaterial,
                {
                  name: 'AES-CBC',
                  length: 256
                },
                false,
                ['decrypt']
              );
              
              // è§£å¯†
              const decrypted = await crypto.subtle.decrypt(
                {
                  name: 'AES-CBC',
                  iv: iv
                },
                key,
                encrypted
              );
              
              return new TextDecoder().decode(decrypted);
            } catch (error) {
              throw new Error('è§£å¯†å¤±è´¥ï¼Œè¯·æ£€æŸ¥å¯†ç æ˜¯å¦æ­£ç¡®');
            }
          }
          
          // ç®€å•çš„ Markdown è§£æå‡½æ•°
          async function markdownToHtml(markdown: string): Promise<string> {
            // åŸºæœ¬çš„ Markdown è§£æ
            let html = markdown
              // æ ‡é¢˜
              .replace(/^### (.*$)/gim, '<h3>$1</h3>')
              .replace(/^## (.*$)/gim, '<h2>$1</h2>')
              .replace(/^# (.*$)/gim, '<h1>$1</h1>')
              // ç²—ä½“
              .replace(/\*\*(.*?)\*\*/gim, '<strong>$1</strong>')
              // æ–œä½“
              .replace(/\*(.*?)\*/gim, '<em>$1</em>')
              // åˆ—è¡¨
              .replace(/^\- (.*$)/gim, '<li>$1</li>')
              .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
              // æ®µè½
              .replace(/^(?!<[h1-6ulli])(.*$)/gim, '<p>$1</p>')
              // ç©ºè¡Œ
              .replace(/\n\n/gim, '</p><p>')
              .replace(/<p><\/p>/gim, '');
            
            return html;
          }
        })();
      </script>
    </>
  )}
</BaseLayout>