---
// 右键菜单组件
import "../styles/right-click-menu.css";
---

<div id="custom-right-click-menu" class="custom-context-menu">
  <ul class="context-menu-list">
    <!-- 通用菜单项 -->
    <li class="context-menu-item general" data-action="refresh">
      <img src="/icons/refresh.svg" alt="刷新" class="context-menu-icon" />
      <span>刷新页面</span>
    </li>
    <li class="context-menu-item general" data-action="paste">
      <img src="/icons/paste.svg" alt="粘贴" class="context-menu-icon" />
      <span>粘贴</span>
    </li>
    <li class="context-menu-item general" data-action="copy-url">
      <img src="/icons/link.svg" alt="复制链接" class="context-menu-icon" />
      <span>复制链接</span>
    </li>
    
    <!-- 选中文本时的菜单项 -->
    <li class="context-menu-item text-selection" data-action="copy">
      <img src="/icons/copy.svg" alt="复制" class="context-menu-icon" />
      <span>复制</span>
    </li>
    <li class="context-menu-item text-selection" data-action="search">
      <img src="/icons/search.svg" alt="搜索" class="context-menu-icon" />
      <span>搜索</span>
    </li>
    <li class="context-menu-item text-selection" data-action="translate">
      <img src="/icons/translate.svg" alt="翻译" class="context-menu-icon" />
      <span>翻译</span>
    </li>
    <li class="context-menu-item text-selection" data-action="share">
      <img src="/icons/share.svg" alt="分享" class="context-menu-icon" />
      <span>分享</span>
    </li>
  </ul>
</div>

<!-- 操作反馈弹窗 -->
<div id="action-feedback" class="action-feedback">
  <div class="feedback-content">
    <svg class="feedback-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="20 6 9 17 4 12"></polyline>
    </svg>
    <span class="feedback-message"></span>
  </div>
</div>

<script>
  // 右键菜单类
  class CustomRightClickMenu {
    private contextMenu: HTMLElement | null;
    private feedbackElement: HTMLElement | null;
    private selectedText: string;
    private justSelectedText: boolean;
    private rightClickTarget: Element | null;
    private lastMouseEvent: MouseEvent | null;
    private lastTouchEvent: TouchEvent | null;
    private touchStartTime: number;
    private touchStartX: number;
    private touchStartY: number;
    private isSelectingText: boolean;
    private touchStartXForSwipe: number;
    private touchStartYForSwipe: number;
    
    // 常量定义
    private readonly LONG_PRESS_THRESHOLD = 500;
    private readonly TOUCH_MOVE_THRESHOLD = 10;
    private readonly MAX_SELECTION_LENGTH = 1000;
    private readonly SWIPE_THRESHOLD = 50;
    private readonly ANIMATION_DURATION = 300;
    private readonly MENU_PADDING = 10;
    
    constructor() {
      this.contextMenu = document.getElementById('custom-right-click-menu');
      this.feedbackElement = document.getElementById('action-feedback');
      this.selectedText = '';
      this.justSelectedText = false;
      this.rightClickTarget = null;
      this.lastMouseEvent = null;
      this.lastTouchEvent = null;
      this.touchStartTime = 0;
      this.touchStartX = 0;
      this.touchStartY = 0;
      this.isSelectingText = false;
      this.touchStartXForSwipe = 0;
      this.touchStartYForSwipe = 0;
      
      this.initEventListeners();
    }
    
    // 初始化事件监听器
    private initEventListeners() {
      // 监听鼠标移动事件
      document.addEventListener('mousemove', (e) => {
        this.lastMouseEvent = e;
      });
      
      // 监听触摸开始事件
      document.addEventListener('touchstart', (e) => {
        this.touchStartTime = Date.now();
        const touch = e.touches[0];
        this.touchStartX = touch.clientX;
        this.touchStartY = touch.clientY;
        this.isSelectingText = false;
      });
      
      // 监听触摸移动事件
      document.addEventListener('touchmove', (e) => {
        this.lastTouchEvent = e;
        // 检测是否正在进行文本选择
        const selection = window.getSelection();
        if (selection && selection.toString().trim().length > 0) {
          this.isSelectingText = true;
          this.optimizeTextSelection(selection);
        }
      });
      
      // 监听触摸结束事件
      document.addEventListener('touchend', (e) => {
        this.handleTouchEnd(e);
      });
      
      // 监听右键点击事件
      document.addEventListener('contextmenu', (e) => {
        this.handleContextMenu(e);
      });
      
      // 监听鼠标抬起事件（文本选择）
      document.addEventListener('mouseup', (e) => {
        this.handleMouseUp(e);
      });
      
      // 点击页面其他地方关闭菜单
      document.addEventListener('click', (e) => {
        if (!this.justSelectedText && (!this.contextMenu || !this.contextMenu.contains(e.target as Node))) {
          this.hideContextMenu();
        }
      });
      
      // 监听键盘事件
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          this.hideContextMenu();
        }
      });
      
      // 监听页面滚动事件
      window.addEventListener('scroll', () => {
        this.hideContextMenu();
      });
      
      // 监听窗口尺寸变化事件
      window.addEventListener('resize', () => {
        this.hideContextMenu();
      });
      
      // 初始化菜单触摸事件
      this.initMenuTouchEvents();
    }
    
    // 初始化菜单触摸事件
    private initMenuTouchEvents() {
      if (!this.contextMenu) return;
      
      // 触摸开始事件（用于滑动检测）
      this.contextMenu.addEventListener('touchstart', (e) => {
        e.preventDefault(); // 阻止默认行为，防止页面滚动
        const touch = e.touches[0];
        this.touchStartXForSwipe = touch.clientX;
        this.touchStartYForSwipe = touch.clientY;
      });
      
      // 触摸移动事件（用于滑动检测）
      this.contextMenu.addEventListener('touchmove', (e) => {
        e.preventDefault(); // 阻止默认行为，防止页面滚动
        this.handleMenuTouchMove(e);
      });
      
      // 触摸反馈事件
      this.contextMenu.addEventListener('touchstart', (e) => {
        e.preventDefault(); // 阻止默认行为，防止页面滚动
        this.handleMenuItemTouchStart(e);
      });
      
      this.contextMenu.addEventListener('touchend', (e) => {
        this.handleMenuItemTouchEnd(e);
      });
      
      this.contextMenu.addEventListener('touchcancel', (e) => {
        this.handleMenuItemTouchCancel(e);
      });
      
      // 菜单点击事件
      this.contextMenu.addEventListener('click', (e) => {
        this.handleMenuClick(e);
      });
    }
    
    // 处理触摸结束事件
    private handleTouchEnd(e: TouchEvent) {
      const touch = e.changedTouches[0];
      const touchEndX = touch.clientX;
      const touchEndY = touch.clientY;
      
      // 检查是否有选中的文本
      const selection = window.getSelection();
      this.selectedText = selection ? selection.toString().trim() : '';
      
      // 如果有选中文本，显示菜单
      if (this.selectedText && this.isSelectingText) {
        this.rightClickTarget = touch.target as Element;
        this.showOrSwitchMenu(touchEndX, touchEndY, e);
      }
    }
    
    // 处理右键点击事件
    private handleContextMenu(e: MouseEvent) {
      e.preventDefault();
      e.stopPropagation();
      
      this.rightClickTarget = e.target as Element;
      
      // 获取选中的文本
      const selection = window.getSelection();
      this.selectedText = selection ? selection.toString().trim() : '';
      
      this.showOrSwitchMenu(e.clientX, e.clientY, e);
    }
    
    // 处理鼠标抬起事件（文本选择）
    private handleMouseUp(e: MouseEvent) {
      // 检查点击目标是否在菜单内
      if (this.contextMenu && this.contextMenu.contains(e.target as Node)) {
        return;
      }
      
      const selection = window.getSelection();
      this.selectedText = selection ? selection.toString().trim() : '';
      
      // 如果有选中的文本，自动显示菜单
      if (this.selectedText && selection && selection.rangeCount > 0) {
        this.justSelectedText = true;
        e.preventDefault();
        e.stopPropagation();
        
        // 100毫秒后重置标志
        setTimeout(() => {
          this.justSelectedText = false;
        }, 100);
        
        this.showOrSwitchMenu(e.clientX, e.clientY, e);
      }
    }
    
    // 显示或切换菜单
    private showOrSwitchMenu(x: number, y: number, event: MouseEvent | TouchEvent) {
      if (!this.contextMenu) return;
      
      const menuVisible = this.contextMenu.style.display === 'block';
      
      if (menuVisible) {
        this.switchContextMenu(x, y, event);
      } else {
        this.showContextMenu(x, y, event);
      }
    }
    
    // 优化文本选择
    private optimizeTextSelection(selection: Selection) {
      if (!selection) return;
      
      const selectedText = selection.toString().trim();
      
      if (selectedText.length > this.MAX_SELECTION_LENGTH * 2) {
        this.showFeedback('选择内容过长，已自动调整');
      }
    }
    
    // 显示右键菜单
    private showContextMenu(x: number, y: number, event?: MouseEvent | TouchEvent) {
      if (!this.contextMenu) return;
      
      // 记录开始时间，用于性能测试
      const startTime = performance.now();
      
      // 根据是否有选中文本显示不同的菜单项
      const hasSelection = this.selectedText.length > 0;
      
      // 显示或隐藏菜单项
      this.updateMenuItems(hasSelection);
      
      // 计算菜单位置
      const { positionX, positionY, menuWidth, menuHeight } = this.calculateMenuPosition(x, y, event);
      
      // 设置菜单位置
      this.contextMenu.style.left = `${positionX}px`;
      this.contextMenu.style.top = `${positionY}px`;
      
      // 添加动画效果
      this.animateMenuIn();
      
      // 性能测试
      const endTime = performance.now();
      const executionTime = endTime - startTime;
      if (executionTime > 16) {
        console.warn(`Context menu positioning took ${executionTime.toFixed(2)}ms, exceeding 16ms threshold`);
      }
    }
    
    // 计算菜单位置
    private calculateMenuPosition(x: number, y: number, event?: MouseEvent | TouchEvent): { positionX: number; positionY: number; menuWidth: number; menuHeight: number } {
      if (!this.contextMenu) return { positionX: x, positionY: y, menuWidth: 0, menuHeight: 0 };
      
      // 先显示菜单以获取正确的尺寸
      this.contextMenu.style.display = 'block';
      this.contextMenu.style.opacity = '0';
      this.contextMenu.style.transform = 'scale(0.9)';
      this.contextMenu.style.transition = 'none';
      
      const menuWidth = this.contextMenu.offsetWidth;
      const menuHeight = this.contextMenu.offsetHeight;
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      
      let positionX = x;
      let positionY = y;
      
      // 检查是否有有效事件，如果没有则使用选区位置
      if (!event && this.selectedText.length > 0) {
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          const rect = range.getBoundingClientRect();
          positionX = rect.right + 5;
          positionY = rect.top + 5;
        }
      }
      
      // 当有选中文本时，确保菜单定位在选中内容的附近
      if (this.selectedText.length > 0) {
        const adjustedPosition = this.adjustPositionForSelection(positionX, positionY, menuWidth, menuHeight, windowWidth, windowHeight, event);
        positionX = adjustedPosition.x;
        positionY = adjustedPosition.y;
      }
      
      // 确保菜单位置在视口内
      positionX = this.clampPosition(positionX, 0, windowWidth - menuWidth - this.MENU_PADDING);
      positionY = this.clampPosition(positionY, 0, windowHeight - menuHeight - this.MENU_PADDING);
      
      // 再次验证，确保菜单不会超出视口
      if (positionX + menuWidth > windowWidth) {
        positionX = windowWidth - menuWidth - this.MENU_PADDING;
      }
      if (positionY + menuHeight > windowHeight) {
        positionY = windowHeight - menuHeight - this.MENU_PADDING;
      }
      if (positionX < this.MENU_PADDING) {
        positionX = this.MENU_PADDING;
      }
      if (positionY < this.MENU_PADDING) {
        positionY = this.MENU_PADDING;
      }
      
      return { positionX, positionY, menuWidth, menuHeight };
    }
    
    // 调整选中文本时的菜单位置
    private adjustPositionForSelection(x: number, y: number, menuWidth: number, menuHeight: number, windowWidth: number, windowHeight: number, event?: MouseEvent | TouchEvent): { x: number; y: number } {
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) return { x, y };
      
      const range = selection.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      
      // 检查是否有有效的事件位置
      let hasValidEventPosition = false;
      if (event instanceof MouseEvent) {
        hasValidEventPosition = true;
      } else if (event instanceof TouchEvent) {
        const touch = event.touches[0] || event.changedTouches[0];
        hasValidEventPosition = !!touch;
      }
      
      // 如果有有效的事件位置，只在需要时调整
      if (hasValidEventPosition) {
        const needsAdjustment = x + menuWidth > windowWidth || x < this.MENU_PADDING || 
                               y + menuHeight > windowHeight || y < this.MENU_PADDING;
        
        if (!needsAdjustment) {
          return { x, y };
        }
      }
      
      // 尝试将菜单定位在选区的不同方向
      if (rect.right + menuWidth + this.MENU_PADDING <= windowWidth) {
        return { x: rect.right + this.MENU_PADDING, y: rect.top };
      } else if (rect.bottom + menuHeight + this.MENU_PADDING <= windowHeight) {
        return { x: rect.left, y: rect.bottom + this.MENU_PADDING };
      } else if (rect.left - menuWidth - this.MENU_PADDING >= 0) {
        return { x: rect.left - menuWidth - this.MENU_PADDING, y: rect.top };
      } else if (rect.top - menuHeight - this.MENU_PADDING >= 0) {
        return { x: rect.left, y: rect.top - menuHeight - this.MENU_PADDING };
      } else {
        // 如果所有方向都不够空间，尝试将菜单定位在选区中心附近
        return {
          x: Math.min(rect.right, windowWidth - menuWidth - this.MENU_PADDING),
          y: Math.min(rect.bottom, windowHeight - menuHeight - this.MENU_PADDING)
        };
      }
    }
    
    // 限制位置在指定范围内
    private clampPosition(value: number, min: number, max: number): number {
      return Math.max(min + this.MENU_PADDING, Math.min(value, max));
    }
    
    // 更新菜单项显示状态
    private updateMenuItems(hasSelection: boolean) {
      if (!this.contextMenu) return;
      
      const generalItems = this.contextMenu.querySelectorAll('.context-menu-item.general');
      const textSelectionItems = this.contextMenu.querySelectorAll('.context-menu-item.text-selection');
      
      generalItems.forEach((item) => {
        if (item.getAttribute('data-action') === 'copy-url' && hasSelection) {
          (item as HTMLElement).style.display = 'none';
        } else {
          (item as HTMLElement).style.display = 'flex';
        }
      });
      
      textSelectionItems.forEach((item) => {
        (item as HTMLElement).style.display = hasSelection ? 'flex' : 'none';
      });
    }
    
    // 菜单淡入动画
    private animateMenuIn() {
      if (!this.contextMenu) return;
      
      requestAnimationFrame(() => {
        this.contextMenu!.style.transition = `opacity ${this.ANIMATION_DURATION}ms cubic-bezier(0.4, 0, 0.2, 1), transform ${this.ANIMATION_DURATION}ms cubic-bezier(0.4, 0, 0.2, 1)`;
        this.contextMenu!.style.opacity = '1';
        this.contextMenu!.style.transform = 'scale(1)';
        
        // 动画完成后重置过渡属性
        setTimeout(() => {
          if (this.contextMenu) {
            this.contextMenu.style.transition = '';
          }
        }, this.ANIMATION_DURATION);
      });
    }
    
    // 隐藏右键菜单
    private hideContextMenu() {
      if (!this.contextMenu || this.contextMenu.style.display === 'none') return;
      
      // 添加淡出动画
      this.contextMenu.style.transition = `opacity ${this.ANIMATION_DURATION}ms cubic-bezier(0.4, 0, 0.2, 1), transform ${this.ANIMATION_DURATION}ms cubic-bezier(0.4, 0, 0.2, 1)`;
      this.contextMenu.style.opacity = '0';
      this.contextMenu.style.transform = 'scale(0.9)';
      
      setTimeout(() => {
        if (this.contextMenu) {
          this.contextMenu.style.display = 'none';
          this.contextMenu.style.transition = '';
        }
      }, this.ANIMATION_DURATION);
    }
    
    // 菜单切换动画
    private switchContextMenu(x: number, y: number, event?: MouseEvent | TouchEvent) {
      if (!this.contextMenu) return;
      
      // 存储新的选中文本状态
      const hasSelection = this.selectedText.length > 0;
      
      // 计算新菜单位置（使用当前菜单尺寸作为估算）
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const currentMenuWidth = this.contextMenu.offsetWidth;
      const currentMenuHeight = this.contextMenu.offsetHeight;
      
      let newX = x;
      let newY = y;
      
      // 当有选中文本时，确保菜单定位在选中内容的附近
      if (hasSelection) {
        const adjustedPosition = this.adjustPositionForSelection(newX, newY, currentMenuWidth, currentMenuHeight, windowWidth, windowHeight, event);
        newX = adjustedPosition.x;
        newY = adjustedPosition.y;
      }
      
      // 确保位置在视口内
      newX = this.clampPosition(newX, 0, windowWidth - currentMenuWidth - this.MENU_PADDING);
      newY = this.clampPosition(newY, 0, windowHeight - currentMenuHeight - this.MENU_PADDING);
      
      // 开始切换动画
      // 1. 缩小并淡出当前菜单
      this.contextMenu.style.transition = 'opacity 200ms cubic-bezier(0.4, 0, 0.2, 1), transform 200ms cubic-bezier(0.4, 0, 0.2, 1)';
      this.contextMenu.style.opacity = '0';
      this.contextMenu.style.transform = 'scale(0.8)';
      
      // 2. 短暂延迟后，移动并淡入新菜单
      setTimeout(() => {
        // 更新菜单项
        this.updateMenuItems(hasSelection);
        
        // 再次验证边界
        const finalMenuWidth = this.contextMenu!.offsetWidth;
        const finalMenuHeight = this.contextMenu!.offsetHeight;
        let finalX = newX;
        let finalY = newY;
        
        // 确保位置在视口内
        if (finalX + finalMenuWidth > windowWidth) {
          finalX = windowWidth - finalMenuWidth - this.MENU_PADDING;
        }
        if (finalY + finalMenuHeight > windowHeight) {
          finalY = windowHeight - finalMenuHeight - this.MENU_PADDING;
        }
        if (finalX < this.MENU_PADDING) {
          finalX = this.MENU_PADDING;
        }
        if (finalY < this.MENU_PADDING) {
          finalY = this.MENU_PADDING;
        }
        
        // 设置新位置
        this.contextMenu!.style.left = `${finalX}px`;
        this.contextMenu!.style.top = `${finalY}px`;
        
        // 重置过渡并显示新菜单
        this.contextMenu!.style.transition = `opacity ${this.ANIMATION_DURATION}ms cubic-bezier(0.4, 0, 0.2, 1), transform ${this.ANIMATION_DURATION}ms cubic-bezier(0.4, 0, 0.2, 1)`;
        this.contextMenu!.style.opacity = '1';
        this.contextMenu!.style.transform = 'scale(1)';
        
        // 3. 动画完成后重置过渡属性
        setTimeout(() => {
          if (this.contextMenu) {
            this.contextMenu.style.transition = '';
          }
        }, this.ANIMATION_DURATION);
      }, 200);
    }
    
    // 处理菜单点击事件
    private handleMenuClick(e: MouseEvent) {
      const target = e.target as HTMLElement;
      if (!target) return;
      
      const menuItem = target.closest('.context-menu-item');
      if (menuItem) {
        const action = menuItem.getAttribute('data-action');
        this.handleMenuAction(action);
        this.hideContextMenu();
      }
    }
    
    // 处理菜单操作
    private handleMenuAction(action: string | null) {
      if (!action) return;
      
      switch (action) {
        case 'refresh':
          window.location.reload();
          break;
        case 'copy':
          if (this.selectedText) {
            navigator.clipboard.writeText(this.selectedText).then(() => {
              this.showFeedback('复制成功');
            }).catch(err => {
              console.error('复制失败:', err);
            });
          }
          break;
        case 'copy-url':
          navigator.clipboard.writeText(window.location.href).then(() => {
            this.showFeedback('链接已复制');
          }).catch(err => {
            console.error('复制链接失败:', err);
          });
          break;
        case 'paste':
          this.handlePaste();
          break;
        case 'search':
          if (this.selectedText) {
            const searchUrl = `https://www.bing.com/search?q=${encodeURIComponent(this.selectedText)}`;
            window.open(searchUrl, '_blank');
          }
          break;
        case 'translate':
          if (this.selectedText) {
            const translateUrl = `https://cn.bing.com/translator/?from=auto&to=zh-Hans&text=${encodeURIComponent(this.selectedText)}`;
            window.open(translateUrl, '_blank');
          }
          break;
        case 'share':
          if (this.selectedText) {
            this.handleShare(this.selectedText);
          }
          break;
        default:
          break;
      }
    }
    
    // 处理粘贴操作
    private handlePaste() {
      navigator.clipboard.readText().then(text => {
        let targetElement: Element | null = document.activeElement;
        
        // 如果没有活动元素，检查右键点击的目标元素
        if (!targetElement || !(targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA')) {
          if (this.rightClickTarget) {
            if (this.rightClickTarget.tagName === 'INPUT' || this.rightClickTarget.tagName === 'TEXTAREA') {
              targetElement = this.rightClickTarget;
            } else {
              const parentInput = this.rightClickTarget.closest('input, textarea');
              if (parentInput) {
                targetElement = parentInput;
              }
            }
          }
        }
        
        // 粘贴到目标输入元素
        if (targetElement && (targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA')) {
          const inputElement = targetElement as HTMLInputElement | HTMLTextAreaElement;
          inputElement.value += text;
          inputElement.focus();
          this.showFeedback('粘贴成功');
        }
      }).catch(err => {
        console.error('粘贴失败:', err);
      });
    }
    
    // 处理分享操作
    private handleShare(text: string) {
      if (navigator.share) {
        // 使用Web Share API
        navigator.share({
          title: '分享文本',
          text: text,
          url: window.location.href
        }).catch(err => {
          console.error('分享失败:', err);
          this.fallbackShare(text);
        });
      } else {
        // 降级方案
        this.fallbackShare(text);
      }
    }
    
    // 分享功能的降级方案
    private fallbackShare(text: string) {
      const shareText = `${text}\n\n来自: ${window.location.href}`;
      navigator.clipboard.writeText(shareText).then(() => {
        this.showFeedback('已复制到剪贴板');
      }).catch(err => {
        console.error('复制失败:', err);
      });
    }
    
    // 显示操作反馈弹窗
    private showFeedback(message: string) {
      if (!this.feedbackElement) return;
      
      // 设置反馈信息
      const messageElement = this.feedbackElement.querySelector('.feedback-message');
      if (messageElement) {
        messageElement.textContent = message;
      }
      
      // 重置动画和显示状态
      this.feedbackElement.style.display = 'flex';
      this.feedbackElement.style.animation = 'none';
      this.feedbackElement.offsetHeight; // 触发重排
      this.feedbackElement.style.animation = `feedbackFadeIn ${this.ANIMATION_DURATION}ms cubic-bezier(0.4, 0, 0.2, 1) forwards, feedbackFadeOut ${this.ANIMATION_DURATION}ms cubic-bezier(0.4, 0, 0.2, 1) ${3000 - this.ANIMATION_DURATION}ms forwards`;
      
      // 3秒后隐藏弹窗
      setTimeout(() => {
        if (this.feedbackElement) {
          this.feedbackElement.style.display = 'none';
        }
      }, 3000);
    }
    
    // 处理菜单触摸移动事件（滑动关闭）
    private handleMenuTouchMove(e: TouchEvent) {
      const touch = e.touches[0];
      const touchEndX = touch.clientX;
      const touchEndY = touch.clientY;
      const deltaX = touchEndX - this.touchStartXForSwipe;
      const deltaY = touchEndY - this.touchStartYForSwipe;
      const swipeDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

      // 如果滑动距离超过阈值，关闭菜单
      if (swipeDistance > this.SWIPE_THRESHOLD) {
        this.hideContextMenu();
      }
    }
    
    // 处理菜单项触摸开始事件
    private handleMenuItemTouchStart(e: TouchEvent) {
      const target = e.target as HTMLElement;
      const menuItem = target.closest('.context-menu-item') as HTMLElement | null;
      if (menuItem) {
        // 添加触摸反馈效果
        menuItem.style.transform = 'scale(0.98)';
        menuItem.style.transition = 'transform 0.1s ease';
      }
    }
    
    // 处理菜单项触摸结束事件
    private handleMenuItemTouchEnd(e: TouchEvent) {
      const target = e.target as HTMLElement;
      const menuItem = target.closest('.context-menu-item') as HTMLElement | null;
      if (menuItem) {
        // 移除触摸反馈效果
        menuItem.style.transform = '';
        menuItem.style.transition = '';
      }
    }
    
    // 处理菜单项触摸取消事件
    private handleMenuItemTouchCancel(e: TouchEvent) {
      const target = e.target as HTMLElement;
      const menuItem = target.closest('.context-menu-item') as HTMLElement | null;
      if (menuItem) {
        // 移除触摸反馈效果
        menuItem.style.transform = '';
        menuItem.style.transition = '';
      }
    }
  }
  
  // 初始化右键菜单
  new CustomRightClickMenu();
</script>
