---
// 右键菜单组件
import "../styles/right-click-menu.css";
---

<div id="custom-right-click-menu" class="custom-context-menu">
  <ul class="context-menu-list">
    <!-- 通用菜单项 -->
    <li class="context-menu-item general" data-action="refresh">
      <img src="/icons/refresh.svg" alt="刷新" class="context-menu-icon" />
      <span>刷新页面</span>
    </li>
    <li class="context-menu-item general" data-action="paste">
      <img src="/icons/paste.svg" alt="粘贴" class="context-menu-icon" />
      <span>粘贴</span>
    </li>
    <li class="context-menu-item general" data-action="copy-url">
      <img src="/icons/link.svg" alt="复制链接" class="context-menu-icon" />
      <span>复制链接</span>
    </li>
    
    <!-- 选中文本时的菜单项 -->
    <li class="context-menu-item text-selection" data-action="copy">
      <img src="/icons/copy.svg" alt="复制" class="context-menu-icon" />
      <span>复制</span>
    </li>
    <li class="context-menu-item text-selection" data-action="search">
      <img src="/icons/search.svg" alt="搜索" class="context-menu-icon" />
      <span>搜索</span>
    </li>
    <li class="context-menu-item text-selection" data-action="translate">
      <img src="/icons/translate.svg" alt="翻译" class="context-menu-icon" />
      <span>翻译</span>
    </li>
    <li class="context-menu-item text-selection" data-action="share">
      <img src="/icons/share.svg" alt="分享" class="context-menu-icon" />
      <span>分享</span>
    </li>
  </ul>
</div>

<!-- 操作反馈弹窗 -->
<div id="action-feedback" class="action-feedback">
  <div class="feedback-content">
    <svg class="feedback-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="20 6 9 17 4 12"></polyline>
    </svg>
    <span class="feedback-message"></span>
  </div>
</div>

<script>
  // 获取菜单元素
  const contextMenu = document.getElementById('custom-right-click-menu');
  const feedbackElement = document.getElementById('action-feedback');
  let selectedText = '';
  let justSelectedText = false;
  let rightClickTarget: Element | null = null;

  // 存储鼠标事件信息
  let lastMouseEvent: MouseEvent | null = null;

  // 监听鼠标移动事件，记录最后一次鼠标位置
  document.addEventListener('mousemove', (e) => {
    lastMouseEvent = e;
  });

  // 监听右键点击事件
  document.addEventListener('contextmenu', (e) => {
    // 阻止默认右键菜单（确保在所有浏览器中都能阻止，特别是Edge）
    e.preventDefault();
    e.stopPropagation();
    
    // 存储右键点击的目标元素
    rightClickTarget = e.target as Element;
    
    // 获取选中的文本
    const selection = window.getSelection();
    selectedText = selection ? selection.toString().trim() : '';
    
    // 检查菜单是否已经显示
    const menuVisible = contextMenu && contextMenu.style.display === 'block';
    
    // 如果菜单已经显示，使用切换动画
    if (menuVisible) {
      switchContextMenu(e.clientX, e.clientY, e);
    } else {
      // 否则直接显示菜单
      showContextMenu(e.clientX, e.clientY, e);
    }
  });

  // 监听文本选择事件，当用户选中文本时自动显示菜单
  document.addEventListener('mouseup', (e) => {
    // 检查点击目标是否在菜单内，如果是则不显示菜单
    if (contextMenu && contextMenu.contains(e.target as Node)) {
      return;
    }
    
    // 检查点击目标是否是输入元素，如果是则使用输入元素的位置
    const target = e.target as Element;
    const isInputElement = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA';
    
    const selection = window.getSelection();
    selectedText = selection ? selection.toString().trim() : '';
    
    // 如果有选中的文本，自动显示菜单
    if (selectedText && selection && selection.rangeCount > 0) {
      // 设置标志，表示刚刚完成了文本选择
      justSelectedText = true;
      e.preventDefault();
      e.stopPropagation();
      // 100毫秒后重置标志，以避免影响后续的点击操作
      setTimeout(() => {
        justSelectedText = false;
      }, 100);
      
      // 检查菜单是否已经显示
      const menuVisible = contextMenu && contextMenu.style.display === 'block';
      
      // 如果菜单已经显示，使用切换动画
      if (menuVisible) {
        switchContextMenu(e.clientX, e.clientY, e);
      } else {
        // 否则直接显示菜单
        showContextMenu(e.clientX, e.clientY, e);
      }
    }
  });

  // 点击页面其他地方关闭菜单
  document.addEventListener('click', (e) => {
    // 如果是刚刚完成了文本选择，不关闭菜单
    if (justSelectedText) return;
    
    // 如果点击的不是菜单本身，才关闭菜单
    if (!contextMenu || !contextMenu.contains(e.target as Node)) {
      hideContextMenu();
    }
  });

  // 显示右键菜单
  function showContextMenu(x: number, y: number, event?: MouseEvent) {
    if (!contextMenu) return;
    
    // 记录开始时间，用于性能测试
    const startTime = performance.now();
    
    // 根据是否有选中文本显示不同的菜单项
    const hasSelection = selectedText.length > 0;
    
    // 显示或隐藏菜单项
    const generalItems = contextMenu.querySelectorAll('.context-menu-item.general');
    const textSelectionItems = contextMenu.querySelectorAll('.context-menu-item.text-selection');
    
    generalItems.forEach((item) => {
      // 对于通用菜单项，始终显示，但复制链接项在有选中文本时隐藏
      if (item.getAttribute('data-action') === 'copy-url' && hasSelection) {
        (item as HTMLElement).style.display = 'none';
      } else {
        (item as HTMLElement).style.display = 'flex';
      }
    });
    
    textSelectionItems.forEach((item) => {
      (item as HTMLElement).style.display = hasSelection ? 'flex' : 'none';
    });
    
    // 计算菜单位置，确保不会超出屏幕
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    // 先显示菜单以获取正确的尺寸
    contextMenu.style.display = 'block';
    contextMenu.style.opacity = '0';
    contextMenu.style.transform = 'scale(0.9)';
    contextMenu.style.transition = 'none'; // 暂时禁用过渡，以便获取尺寸
    
    const menuWidth = contextMenu.offsetWidth;
    const menuHeight = contextMenu.offsetHeight;
    
    // 调整位置
    let positionX = x;
    let positionY = y;
    
    // 检查是否有有效鼠标事件，如果没有则使用选区位置
    if (!event && hasSelection) {
      const selection = window.getSelection();
      if (selection && selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        const rect = range.getBoundingClientRect();
        // 使用选区末尾或中心作为参考
        positionX = rect.right + 5;
        positionY = rect.top + 5;
      }
    }
    
    // 当有选中文本时，确保菜单定位在选中内容的附近
    if (hasSelection && event) {
      const selection = window.getSelection();
      if (selection && selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        const rect = range.getBoundingClientRect();
        
        // 检查点击位置是否在选区内
        const clickInSelection = 
          event.clientX >= rect.left && 
          event.clientX <= rect.right && 
          event.clientY >= rect.top && 
          event.clientY <= rect.bottom;
        
        // 如果点击位置在选区内，调整菜单位置以避免遮挡选中内容
        if (clickInSelection) {
          // 尝试将菜单定位在选区的右侧或下方
          if (rect.right + menuWidth + 10 <= windowWidth) {
            positionX = rect.right + 10;
            positionY = rect.top;
          } else if (rect.bottom + menuHeight + 10 <= windowHeight) {
            positionX = rect.left;
            positionY = rect.bottom + 10;
          } else if (rect.left - menuWidth - 10 >= 0) {
            positionX = rect.left - menuWidth - 10;
            positionY = rect.top;
          } else if (rect.top - menuHeight - 10 >= 0) {
            positionX = rect.left;
            positionY = rect.top - menuHeight - 10;
          }
        }
      }
    }
    
    // 避免菜单超出视口右侧
    if (positionX + menuWidth > windowWidth) {
      positionX = windowWidth - menuWidth - 10;
    }
    
    // 避免菜单超出视口左侧
    if (positionX < 10) {
      positionX = 10;
    }
    
    // 避免菜单超出视口底部
    if (positionY + menuHeight > windowHeight) {
      positionY = windowHeight - menuHeight - 10;
    }
    
    // 避免菜单超出视口顶部
    if (positionY < 10) {
      positionY = 10;
    }
    
    // 确保菜单位置在视口内
    positionX = Math.max(10, Math.min(positionX, windowWidth - menuWidth - 10));
    positionY = Math.max(10, Math.min(positionY, windowHeight - menuHeight - 10));
    
    // 设置菜单位置
    contextMenu.style.left = `${positionX}px`;
    contextMenu.style.top = `${positionY}px`;
    
    // 添加动画效果
    requestAnimationFrame(() => {
      contextMenu.style.transition = 'opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
      contextMenu.style.opacity = '1';
      contextMenu.style.transform = 'scale(1)';
      
      // 动画完成后重置过渡属性
      setTimeout(() => {
        contextMenu.style.transition = '';
      }, 300);
    });
    
    // 性能测试
    const endTime = performance.now();
    const executionTime = endTime - startTime;
    if (executionTime > 16) {
      console.warn(`Context menu positioning took ${executionTime.toFixed(2)}ms, exceeding 16ms threshold`);
    }
  }

  // 隐藏右键菜单
  function hideContextMenu() {
    if (!contextMenu || contextMenu.style.display === 'none') return;
    
    // 添加淡出动画
    contextMenu.style.transition = 'opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
    contextMenu.style.opacity = '0';
    contextMenu.style.transform = 'scale(0.9)';
    
    setTimeout(() => {
      contextMenu.style.display = 'none';
      // 重置过渡属性
      contextMenu.style.transition = '';
    }, 300);
  }

  // 菜单切换动画
  function switchContextMenu(x: number, y: number, event?: MouseEvent) {
    if (!contextMenu) return;
    
    // 获取当前菜单位置和尺寸
    const currentRect = contextMenu.getBoundingClientRect();
    
    // 计算新菜单位置
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    // 存储新的选中文本状态
    const hasSelection = selectedText.length > 0;
    
    // 计算新菜单位置（考虑视口边界）
    let newX = x;
    let newY = y;
    
    // 先计算临时菜单位置以获取尺寸
    // 创建临时元素来计算新菜单的尺寸
    const tempMenu = document.createElement('div');
    tempMenu.style.position = 'fixed';
    tempMenu.style.visibility = 'hidden';
    tempMenu.style.opacity = '0';
    tempMenu.className = 'custom-context-menu';
    tempMenu.innerHTML = contextMenu.innerHTML;
    document.body.appendChild(tempMenu);
    
    // 根据新的选中文本状态更新临时菜单项
    const tempGeneralItems = tempMenu.querySelectorAll('.context-menu-item.general');
    const tempTextSelectionItems = tempMenu.querySelectorAll('.context-menu-item.text-selection');
    
    tempGeneralItems.forEach((item) => {
      if (item.getAttribute('data-action') === 'copy-url' && hasSelection) {
        (item as HTMLElement).style.display = 'none';
      } else {
        (item as HTMLElement).style.display = 'flex';
      }
    });
    
    tempTextSelectionItems.forEach((item) => {
      (item as HTMLElement).style.display = hasSelection ? 'flex' : 'none';
    });
    
    // 获取新尺寸
    const newWidth = tempMenu.offsetWidth;
    const newHeight = tempMenu.offsetHeight;
    
    // 移除临时元素
    document.body.removeChild(tempMenu);
    
    // 调整新菜单位置以避免超出视口
    // 避免超出视口右侧
    if (newX + newWidth > windowWidth) {
      newX = windowWidth - newWidth - 10;
    }
    
    // 避免超出视口左侧
    if (newX < 10) {
      newX = 10;
    }
    
    // 避免超出视口底部
    if (newY + newHeight > windowHeight) {
      newY = windowHeight - newHeight - 10;
    }
    
    // 避免超出视口顶部
    if (newY < 10) {
      newY = 10;
    }
    
    // 确保位置在视口内
    newX = Math.max(10, Math.min(newX, windowWidth - newWidth - 10));
    newY = Math.max(10, Math.min(newY, windowHeight - newHeight - 10));
    
    // 开始切换动画
    // 1. 缩小并淡出当前菜单
    contextMenu.style.transition = 'opacity 0.2s cubic-bezier(0.4, 0, 0.2, 1), transform 0.2s cubic-bezier(0.4, 0, 0.2, 1)';
    contextMenu.style.opacity = '0';
    contextMenu.style.transform = 'scale(0.8)';
    
    // 2. 短暂延迟后，移动并淡入新菜单
    setTimeout(() => {
      // 根据新的选中文本状态更新菜单项
      const generalItems = contextMenu.querySelectorAll('.context-menu-item.general');
      const textSelectionItems = contextMenu.querySelectorAll('.context-menu-item.text-selection');
      
      generalItems.forEach((item) => {
        if (item.getAttribute('data-action') === 'copy-url' && hasSelection) {
          (item as HTMLElement).style.display = 'none';
        } else {
          (item as HTMLElement).style.display = 'flex';
        }
      });
      
      textSelectionItems.forEach((item) => {
        (item as HTMLElement).style.display = hasSelection ? 'flex' : 'none';
      });
      
      // 设置新位置
      contextMenu.style.left = `${newX}px`;
      contextMenu.style.top = `${newY}px`;
      
      // 重置过渡并显示新菜单
      contextMenu.style.transition = 'opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
      contextMenu.style.opacity = '1';
      contextMenu.style.transform = 'scale(1)';
      
      // 3. 动画完成后重置过渡属性
      setTimeout(() => {
        contextMenu.style.transition = '';
      }, 300);
    }, 200);
  }

  // 处理菜单点击事件
  if (contextMenu) {
    contextMenu.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      if (target) {
        const menuItem = target.closest('.context-menu-item');
        if (menuItem) {
          const action = menuItem.getAttribute('data-action');
          handleMenuAction(action);
          hideContextMenu();
        }
      }
    });
  }

  // 处理菜单操作
  function handleMenuAction(action: string | null) {
    if (!action) return;
    
    switch (action) {
      case 'refresh':
        // 刷新页面
        window.location.reload();
        break;
      case 'copy':
        // 复制选中的文本
        if (selectedText) {
          navigator.clipboard.writeText(selectedText).then(() => {
            showFeedback('复制成功');
          }).catch(err => {
            console.error('复制失败:', err);
          });
        }
        break;
      case 'copy-url':
        // 复制当前URL
        navigator.clipboard.writeText(window.location.href).then(() => {
          showFeedback('链接已复制');
        }).catch(err => {
          console.error('复制链接失败:', err);
        });
        break;
      case 'paste':
        // 粘贴内容到当前活动元素或右键点击的目标元素
        navigator.clipboard.readText().then(text => {
          let targetElement: Element | null = document.activeElement;
          
          // 如果没有活动元素，检查右键点击的目标元素
          if (!targetElement || !(targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA')) {
            // 检查右键点击的目标元素是否是输入元素，或者是否在输入元素内
            if (rightClickTarget) {
              // 检查目标元素本身是否是输入元素
              if (rightClickTarget.tagName === 'INPUT' || rightClickTarget.tagName === 'TEXTAREA') {
                targetElement = rightClickTarget;
              } else {
                // 检查目标元素的父元素是否是输入元素
                const parentInput = rightClickTarget.closest('input, textarea');
                if (parentInput) {
                  targetElement = parentInput;
                }
              }
            }
          }
          
          // 粘贴到目标输入元素
          if (targetElement && (targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA')) {
            const inputElement = targetElement as HTMLInputElement | HTMLTextAreaElement;
            inputElement.value += text;
            // 聚焦到输入元素，确保用户可以继续编辑
            inputElement.focus();
            showFeedback('粘贴成功');
          } else {
            // 如果没有可粘贴的输入元素，可以考虑其他处理方式
            console.log('没有可粘贴的输入元素');
          }
        }).catch(err => {
          console.error('粘贴失败:', err);
        });
        break;
      case 'search':
        // 搜索选中文本
        if (selectedText) {
          const searchUrl = `https://www.bing.com/search?q=${encodeURIComponent(selectedText)}`;
          window.open(searchUrl, '_blank');
        }
        break;
      case 'translate':
        // 翻译选中文本
        if (selectedText) {
          const translateUrl = `https://cn.bing.com/translator/?from=auto&to=zh-Hans&text=${encodeURIComponent(selectedText)}`;
          window.open(translateUrl, '_blank');
        }
        break;
      case 'share':
        // 分享选中文本
        if (selectedText) {
          if (navigator.share) {
            // 使用Web Share API
            navigator.share({
              title: '分享文本',
              text: selectedText,
              url: window.location.href
            }).catch(err => {
              console.error('分享失败:', err);
              // 降级方案
              fallbackShare(selectedText);
            });
          } else {
            // 降级方案：复制到剪贴板
            fallbackShare(selectedText);
          }
        }
        break;
      default:
        break;
    }
  }
  
  // 分享功能的降级方案
  function fallbackShare(text: string) {
    const shareText = `${text}\n\n来自: ${window.location.href}`;
    navigator.clipboard.writeText(shareText).then(() => {
      showFeedback('已复制到剪贴板');
    }).catch(err => {
      console.error('复制失败:', err);
    });
  }

  // 显示操作反馈弹窗
  function showFeedback(message: string) {
    if (!feedbackElement) return;
    
    // 设置反馈信息
    const messageElement = feedbackElement.querySelector('.feedback-message');
    if (messageElement) {
      messageElement.textContent = message;
    }
    
    // 重置动画和显示状态
    feedbackElement.style.display = 'flex';
    feedbackElement.style.animation = 'none';
    feedbackElement.offsetHeight; // 触发重排
    feedbackElement.style.animation = 'feedbackFadeIn 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards, feedbackFadeOut 0.3s cubic-bezier(0.4, 0, 0.2, 1) 2.7s forwards';
    
    // 3秒后隐藏弹窗
    setTimeout(() => {
      feedbackElement.style.display = 'none';
    }, 3000);
  }

  // 监听键盘事件，按ESC键关闭菜单
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      hideContextMenu();
    }
  });

  // 监听页面滚动事件，滚动时关闭菜单
  window.addEventListener('scroll', () => {
    hideContextMenu();
  });

  // 监听窗口尺寸变化事件，调整菜单位置
  window.addEventListener('resize', () => {
    // 窗口尺寸变化时关闭菜单，以避免位置计算错误
    hideContextMenu();
  });
</script>
